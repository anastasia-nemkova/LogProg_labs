## Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Немкова А.Р.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Обработка естественных и искусственных языков часто включает в себя применение двух основных подходов - статического и лингвистического. 

Статический подход, как правило, используется в императивных языках программирования, поскольку его основной идеей является анализ значения текста через подсчет повторений слов. Такой подход удобен для работы с языками, основанными на последовательном выполнении команд.

В свою очередь, лингвистический подход основывается на разбиении текста на графемы в соответствии с грамматикой языка, что позволяет более точно определить семантику текста. Пролог, благодаря своей способности удобно работать со списками, позволяет эффективно представлять и обрабатывать структурированные данные. Кроме того, механизмы перебора и backtracking в прологе обеспечивают гибкость при анализе текста и поиске решений.

Пролог также позволяет легко выражать и проверять грамматические правила. Путем перебора фактов в прологе можно реализовать грамматику, не зависящую от количества элементов, а затем легко расширить список фактов для дополнительной настройки готовой грамматики. Благодаря этим возможностям, пролог становится удобным инструментом для решения задач обработки языка и лингвистического анализа.

## Задание

4. Реализовать синтаксический анализатор арифметического выражения для перевода его в префиксную форму. 
В выражении допустимы операции +, -, *, /.

---
Запрос:
```prolog
?- calculate([5, +, 2, *, 3]).
```
Результат:
```prolog
X = ['+', 5, '*', 2, 3]
```

## Принцип решения

Терминальные символы: `{ 0 - 9, '+', '-', '*', '/'}`

Нетерминальные символы: `{Expr, Term, Number}`

Начало: `Expr`

Грамматика языка (реверсированная):

```
Expr --> Term | Term, ['+', Expr] | Term, ['-', Expr]
Term --> Number | Number, ['*', Number] | Number, ['/', Number]
Number --> [0-9]
```

В данной грамматике:

* `Expr` представляет собой инфиксное выражение.
* `Term` представляет собой множество термов, объединенных сложением или вычитанием.
* `Number` представляет собой числа от 0 до 9.

Предикат `a_number([NS], NS)`  проверяет является ли элемент списка числом.
```prolog
a_number([NS], NS) :- number(NS).
```
Предикат `a_expr(T, V)` обрабатывает сложение и вычитание.
* Если `T` является термом, то `V` принимает значение терма.
* Если `T` начинается с `+`, то он разбивается на две части, и рекурсивно вызывает себя для обеих частей. Результат объединяется в одном списке.
* Аналогично, если `T` начинается с `-`.
```prolog
a_expr(T, V) :- a_term(T, V).
a_expr(T, V) :- 
    append(X, ['+'|Y], T),
    a_term(X, Vx),
    a_expr(Y, Vy),
    V = ['+', Vy, Vx].
a_expr(T, V) :- 
    append(X, ['-'|Y], T),
    a_term(X, Vx),
    a_expr(Y, Vy),
    V = ['-', Vy, Vx].
```

Предикат `a_term(T, V)` обрабатывает умножение и деление в выражении.
* Если `T` является числом, то `V` принимает это значение.
* Если `T` начинается с умножения, то он разбивается на две части, и рекурсивно вызывает себя для обеих частей. Результат объединяется в одном списке.
* Аналогично, если `T` начинается с деления.
```prolog
a_term(T, V) :- a_number(T, V).
a_term(T, V) :- 
    append(X, ['*'|Y], T),
    a_number(X, Vx),
    a_term(Y, Vy),
    V = ['*', Vy , Vx].

a_term(T, V) :- 
    append(X, ['/'|Y], T),
    a_number(X, Vx),
    a_term(Y, Vy),
    V = ['/', Vy, Vx].
```

Предикат `calculate(Expr)` запускает процесс вычисления. Он принимает инфиксное выражение, реверсирует его, затем передает для обработки и отправляет результат в префиксной форме на вывод.

```prolog
calculate(Expr) :- 
    reverse(Expr, Expr1),
    a_expr(Expr1, Val),
    write('Res = ['), write_expr(Val), writeln(']').
```

Предикат `write_expr` выводит префиксную форму арифметического выражения.
```prolog
write_expr(Num) :- 
    number(Num),
    write(Num).
write_expr([Operator, Left, Right]) :- 
    write(Operator),
    write(', '),
    write_expr(Left),
    write(', '),
    write_expr(Right).
```

## Результаты

```prolog
?- calculate([5, '+', 2, '*', 3]).
Res = [+, 5, *, 2, 3]
true .

?- calculate([7, '+', 9, '*', 7]).
Res = [+, 7, *, 9, 7]
true .

?- calculate([46, '+', 100, '-', 17, '*', 1, '+', 69, '/', 2]).
Res = [+, -, +, 46, 100, *, 17, 1, /, 69, 2]
true .

?- calculate([46, '+', 100, '/', 17, '*', 1, '+', 69, '/', 2]).
Res = [+, +, 46, *, /, 100, 17, 1, /, 69, 2]
true .

?- calculate([7, '/', 3, '+', 9, '*', 4, '+', 12]).
Res = [+, +, /, 7, 3, *, 9, 4, 12]
true .
```

## Выводы

В ходе выполнения лабораторной работы я ознакомилась с использованием языка программирования Prolog для решения задач грамматического разбора. Эта работа заставила меня задуматься над эффективностью и удобством применения логических языков программирования, таких как Prolog, в контексте анализа и обработки языков.

Лабораторная работа подчеркнула удобство использования Prolog'а  для реализации синтаксического анализатора. Описывая грамматику языка с помощью правил и фактов, можно естественным образом представить структуру языка, что делает код более читаемым и понятным. Механизм унификации и рекурсивные правила в Prolog'е позволяют компактно описывать сложные структуры данных.

Однако для эффективного использования Prolog'а в таких задачах необходимо внимательное проектирование грамматики и структурирование кода. Кроме того, хранение большой базы фактов может потребовать дополнительных усилий при масштабировании программы.








