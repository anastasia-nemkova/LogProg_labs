## Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Немкова А.Р.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Метод поиска в пространстве состояний удобен для решения задач, где объект или система может находиться в различных дискретных состояниях, с определенными правилами и условиями перехода между ними. Примером такой задачи может быть поиск оптимального пути в лабиринте, планирование действий робота или игры, где игрок принимает решения, ведущие к различным состояниям игрового мира.

Prolog оказывается удобным языком для решения подобных задач из-за своей основы на языке предикатов математической логики. В Prolog программирование основано на выражении отношений и фактов с использованием правил логики. Это позволяет естественным образом представлять состояния и правила перехода между ними.

## Задание

6. Вдоль доски расположено 8 лунок, в которых лежат 4 черных и 3 белых шара. Передвинуть черные шары на место белых, а белые - на место черных. Шар можно передвинуть в соседнюю с ним пустую лунку, либо в пустую лунку, находящуюся непосредственно за ближайшим шаром. При этом черные шары можно передвигать только вправо, а белые - только влево.

## Принцип решения

Предикат `move` определяет возможные варианты перемещения шаров (`In` представляет собой текущее состояние, `Out` — новое состояние после выполнения правила):
* Если слева от белого шара пустая лунка, то меняем их метами
* Если справа от черного шара пустая лунка, то меняем их местами
* Если идет пустая лунка, черный шар и белый шар, то белый шар и пустую лунку меняем местами
* Если идет черный шар, белый шар и пустая лунка, то черный щар и пустую лунку меняем местами

```prolog
move(In,Out):-
	append(S,['_','w'|T],In),
	append(S,['w','_'|T],Out).
move(In,Out):-
	append(S,['b','_'|T],In),
	append(S,['_','b'|T],Out).
move(In,Out):-
	append(S,['_','b','w'|T],In),
	append(S,['w','b','_'|T],Out).
move(In,Out):-
	append(S,['b','w','_'|T],In),
	append(S,['_','w','b'|T],Out).
```
Предикат `prolong` используется для продления пути с предотвращением петель. Предикат берет текущий путь и создает новый путь `[Y, X|T]`, где `Y` получается применением одного из правил перемещения и не встречался ранее в текущем пути.

```prolog
prolong([X|T], [Y, X|T]) :-
    move(X, Y),
    not(member(Y, [X|T])).
```

Предикат `my_integer` генерирует последовательность целых чисел, начиная с 1.

```prolog
my_integer(1).
my_integer(M) :- my_integer(N), M is N + 1.
```

Предикат `print` - рекурсивно выводит список решений.

```prolog
print([]).
print([H|T]) :-
    print(T),
    writeln(H).
```

Предикат для поиска в глубину `dfs`
1. Не гарантирует нахождение кратчайшего пути.
2. Исследует путь до самого конца перед тем, как вернуться и попробовать другой путь.
3. Использует стек для хранения вершин, что может привести к экономии памяти.
4. Расход по памяти - O(l), где l - длина рассматриваемого пути

```prolog
dfs([X|T], X, [X|T]).
dfs(P, Y, R) :-
    prolong(P, P1), dfs(P1, Y, R).
```
Предикат `dfs_search(In, Out)` для вывода результата поиска в глубину, времени его выполнения и длины пути

```prolog
dfs_search(In, Out) :-
    writeln('DFS'),
    get_time(Start),
    dfs([In], Out, Res),
    get_time(End),
    Time is End - Start,
    print(Res), nl,
    length(Res, Len),write('DFS-search length: '),writeln(Len),
    write('Time: '), writeln(Time), nl.
```

Предикат для поиска в ширину `bfs`
1. Рассматривает все узлы на текущем уровне перед переходом на следующий уровень.
2. Гарантирует нахождение кратчайшего пути к цели.
3. Использует очередь, что может привести к использованию большей памяти по сравнению с DFS.
4. Позволяет искать в путях с циклами

```prolog
bfs([[X|T]|_], X, [X|T]).
bfs([P|QI], X, R) :-
    findall(Z, prolong(P, Z), T),
    append(QI, T, QO), !,
    bfs(QO, X, R).
bfs([_|T], Y, L) :- bfs(T, Y, L).
```
Предикат `bfs_search(In, Out)` для вывода результата поиска в ширину, времени его выполнения и длины пути

```prolog
bfs_search(In, Out) :-
    writeln('BFS'),
    get_time(Start),
    bfs([[In]], Out, Res),
    get_time(End),
    Time is End - Start,
    print(Res), nl,
    length(Res, Len),write('BFS-search length: '),writeln(Len),
    write('Time: '), writeln(Time), nl.
```
Предикат для поиска с итерационным заглублением `search_id`
1. Комбинирует преимущества глубинного и широкого поиска, предлагая поиск в глубину с ограничением глубины.
2. Позволяет находить кратчайший путь, при этом не требует большого объема памяти, как BFS.
3. Сложность O(k^l), где k - количество итераций, l - длина рассматриваемого пути
   
```prolog
search_id(Start, Finish, Path) :-
    my_integer(Level), 
    search_id(Start, Finish, Path, Level).

search_id(Start, Finish, Path, DepthLimit) :-
    depth_id([Start], Finish, Path, DepthLimit).

% Отсечение путей, которые не соответствуют заданной глубине
depth_id([Finish|T], Finish, [Finish|T], 0).
depth_id(Path, Finish, R, N) :-
    N > 0,
    prolong(Path, NewPath),
    N1 is N - 1,
    depth_id(NewPath, Finish, R, N1).
```
Предикат `iter_search(In, Out)` для вывода результата поиска с итерационным заглублением, времени его выполнения и длины пути

```prolog
iter_search(In, Out) :-
    writeln('Iterative'),
    get_time(Start),
    search_id(In, Out, Res),
    get_time(End),
    Time is End - Start,
    print(Res), nl,
    length(Res, Len),write('Iter-search length: '),writeln(Len),
    write('Time: '), writeln(Time), nl.
```


## Результаты

Предикаты выводят найденный путь в каждом из алгоритмов, время затраченное на поиск этого пути и длину пути.

```prolog

?- solve.
DFS
[b,b,b,b,_,w,w,w]
[b,b,b,b,w,_,w,w]
[b,b,b,_,w,b,w,w]
[b,b,_,b,w,b,w,w]
[b,b,w,b,_,b,w,w]
[b,b,w,b,w,b,_,w]
[b,b,w,b,w,b,w,_]
[b,b,w,b,w,_,w,b]
[b,b,w,_,w,b,w,b]
[b,_,w,b,w,b,w,b]
[_,b,w,b,w,b,w,b]
[w,b,_,b,w,b,w,b]
[w,b,w,b,_,b,w,b]
[w,b,w,b,w,b,_,b]
[w,b,w,b,w,_,b,b]
[w,b,w,_,w,b,b,b]
[w,_,w,b,w,b,b,b]
[w,w,_,b,w,b,b,b]
[w,w,w,b,_,b,b,b]
[w,w,w,_,b,b,b,b]

DFS-search length: 20
Time: 0.0037894248962402344

BFS
[b,b,b,b,_,w,w,w]
[b,b,b,b,w,_,w,w]
[b,b,b,_,w,b,w,w]
[b,b,_,b,w,b,w,w]
[b,b,w,b,_,b,w,w]
[b,b,w,b,w,b,_,w]
[b,b,w,b,w,b,w,_]
[b,b,w,b,w,_,w,b]
[b,b,w,_,w,b,w,b]
[b,_,w,b,w,b,w,b]
[_,b,w,b,w,b,w,b]
[w,b,_,b,w,b,w,b]
[w,b,w,b,_,b,w,b]
[w,b,w,b,w,b,_,b]
[w,b,w,b,w,_,b,b]
[w,b,w,_,w,b,b,b]
[w,_,w,b,w,b,b,b]
[w,w,_,b,w,b,b,b]
[w,w,w,b,_,b,b,b]
[w,w,w,_,b,b,b,b]

BFS-search length: 20
Time: 0.0017321109771728516

Iterative
[b,b,b,b,_,w,w,w]
[b,b,b,b,w,_,w,w]
[b,b,b,_,w,b,w,w]
[b,b,_,b,w,b,w,w]
[b,b,w,b,_,b,w,w]
[b,b,w,b,w,b,_,w]
[b,b,w,b,w,b,w,_]
[b,b,w,b,w,_,w,b]
[b,b,w,_,w,b,w,b]
[b,_,w,b,w,b,w,b]
[_,b,w,b,w,b,w,b]
[w,b,_,b,w,b,w,b]
[w,b,w,b,_,b,w,b]
[w,b,w,b,w,b,_,b]
[w,b,w,b,w,_,b,b]
[w,b,w,_,w,b,b,b]
[w,_,w,b,w,b,b,b]
[w,w,_,b,w,b,b,b]
[w,w,w,b,_,b,b,b]
[w,w,w,_,b,b,b,b]

Iter-search length: 20
Time: 0.007474184036254883

true .
```

| Алгоритм поиска |  Длина найденного первым пути  |  Время работы  |
|-----------------|:------------------------------:|:----------------:|
| В глубину       |  20  | 0.0037894248962402344 |
| В ширину        |  20 | 0.0017321109771728516|
| ID              |  20 |  0.007474184036254883 |

## Выводы

В данной лабораторной работе было изучено использование языка программирования Prolog для решения задачи поиска в пространстве состояний. В частности, рассмотренные алгоритмы поиска в глубину, поиска в ширину и итеративного поиска дали представление о различных стратегиях их применения.

Данная работа заставила меня задуматься над эффективностью алгоритмов в различных сценариях. Например, поиск в глубину подходит для задач с большим пространством состояний, но может не быть оптимальным в случае большой глубины решения. Поиск в ширину хорош для нахождения кратчайшего пути, но может потребовать больше памяти. Итеративный поиск предоставляет компромисс между ними, позволяя управлять глубиной поиска.

В моей задаче самым эффективным оказался поиск в глубину. Так как в отличии от остальных, пространство состояний было ограниченным и ему не пришлось проходить по боковым веткам дерева запросов.

Таким образом, лабораторная работа подчеркнула важность выбора алгоритма поиска в зависимости от структуры пространства состояний и характеристик задачи.





