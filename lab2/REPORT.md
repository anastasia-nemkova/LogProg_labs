## Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Немкова А.Р.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Существует множество различных подходов к решению логических задач. Основные из них:

* Метод рассуждений - последовательное рассмотрение условий задачи с учетом всех предоставленных фактов
* Метод таблиц истинности - сопоставлений условий задачи формулам алгебры логики, с последующим построением таблицы, которая может использоваться для решения задачи или составления связанное формулы, решаемой другими методами
* Метод кругов Эйлера(графический) - представление ветвей решений в виде абстрактных множеств, где пересечение этих множеств будет являться решением
* Метод ветвей и границ - "отсечение" заведомо неверных решений
* Метод порождения и проверок - использование предикатов как абстрактных множеств, которые в последствии обрабатываются другими предикатами

Багодаря своему механизму поиска ответа(перебор, основанный на дереве возможных решений), Prolog является удобным средством для эффективного решения подобных задач. Также Prolog позволяет решать задачи, основываясь только на предикатах, принимающих истинное или ложное значение, что обеспечивает экономию времени.

## Задание

13. Давным-давно в одной из восточных стран был знаменитый оракул. В отличие от остальных оракулов, его устами вещало не одно божество, а три, Бог Правды, Бог Дипломатии и Бог Лжи. Эти божества изображались совершенно одинаковыми фигурами, расположенными в ряд за алтарем, перед которыми преклоняли колени люди, ищущие совета. Боги всегда охотно отвечали на вопросы. Но так как они были похожи друг на друга, никто не мог определить, то ли отвечает бог Правды, которому надо верить, то ли бог Лжи, который всегда говорит неправду, то ли бог Дипломатии, который может и солгать, и сказать правду. Такое положение было на руку жрецам, ибо любой ответ оракула можно было толковать как угодно. Но однажды нашелся кощунственный смельчак, который задумал совершить то, что не удавалось самым большим мудрецам. Он решил опознать каждого из богов. Смельчак вошел в храм и спросил бога, стоящего слева:  Кто стоит рядом с тобой?  Бог Правды, был ответ. Тогда смельчак спросил бога, стоявшего в центре:  Кто ты?  Бог Дипломатии. Последний вопрос смельчак задал богу, стоявшему справа:  Кто стоит рядом с тобой?  Бог Лжи.  Теперь все понятно,- довольно сказал смельчак. Что же он понял из ответов богов? 

## Принцип решения

Принцип решения задачи заключается в проверке всех возможных вариантов, учитывая высказывания богов и их характеристики. Мы отталкиваемся от предположений по поводу центрального бога и учитываем, что все высказывания богов различны. Далее проходим предикаты при учете каждого бога на позиции в центре.

Определяем список богов (Правда, Дипломатия, Ложь).
```Prolog
gods([truth, dipl, lie]).
```
Задаем высказывания богов.
```Prolog
speak(left, [_, truth, _]).
speak(center, [_, dipl, _]).
speak(right, [_, lie, _]).
```
Предикат `task` вызывает предположения характеристики(правда, ложь или дипломатия) бога в центре. Он вызывает три вспомогательных предиката для каждого возможного варианта, и если хотя бы один из них выполняется, то задача решена и выводится список правильной последовательности богов.
```Prolog
task :-
    center_conditions_truth(truth, _, _);
    center_conditions_dipl(dipl, _);
    center_conditions_lie(lie, _).
```
Предикат `center_conditions_truth(truth, L, L1)` проверяет выполнение высказываний богов при условии, что бог Правды находится в центре. 

Проверяем, что в центре действительно находится бог Правды: исходное высказывание центрального бога должно быть истинным. Тогда характеристика богов слева и справа не имеет принципиального значения, так как они оба могут иметь ложные высказвания. Получим две, удовлетворяющие данному условию последовательности богов.
```Prolog
center_conditions_truth(truth, L, L1) :-
    choice(center, truth, L),
    choice(center, truth, L1),
    speak(center, Ans),
    (compare_second(Ans, L), 
        (choice(left, lie, L),
        choice(right, dipl, L),
        choice(left, dipl, L1),
        choice(right, lie, L1)
        )
    ),
    writeln(L1),
    writeln(L).
```
Предикат `center_conditions_dipl(dipl, L)` проверяет выполнение высказываний богов при условии, что бог Дипломатии находится в центре.

Проверяем, что высказывание центрального бога не является "бог Правды", так как в таком случае высказывание бога Лжи будет истинно. Далее определяем богов слева и справа: сначала определяем позицию бога с истинным высказванием("бог Дипломатии в центре"), затем на оставшуюся позицию записываем бога Лжи. Получим одну последовательность богов, удовлетворяющую исходным условиям.
```Prolog
center_conditions_dipl(dipl, L) :-
    choice(center, dipl, L),
    speak(center, Ans),
    (not(compare_second(Ans, [_, truth, _])), 
        (speak(T, L),
        choice(T, truth, L),
        choice(center, truth, Ost),
        speak(Li, Ost),
        choice(Li, lie, L)
        )
    ),
    writeln(L).
```
Предикат `center_conditions_lie(lie, L)` проверяет выполнение высказываний богов при условии, что бог Лжи находится в центре.

Проверяем, сто в центре действительно бог лжи, т.е. высказывание центрального бога не является "бог Лжи". Далее также определяем богов слева и справа: сначала определяем позицию бога с истинным высказванием("бог Лжи в центре"), затем на оставшуюся позицию записываем бога Дипломатии. Получим одну последовательность богов, удовлетворяющую исходным условиям.
```Prolog
center_conditions_lie(lie, L) :-
    choice(center, lie, L),
    speak(center, Ans),
    (not(compare_second(Ans, L)),
        (speak(T, L),
        choice(T, truth, L),
        choice(center, truth, Ost),
        speak(Li, Ost),
        choice(Li, dipl, L)
        )
    ),
    writeln(L).
```
Вспомагательные предикаты:

1) `choice(Position, V, [H1, H2, H3])` - присваивает определенную характеристику (правда, ложь, дипломатия) богу на заданной позиции.
   
    ```Prolog
    choice(Position, V, [H1, H2, H3]) :-
      (Position = left, H1 = V);
      (Position = center, H2 = V);
      (Position = right, H3 = V).
    ```
2) `compare_second` - проверяет равенство вторых элементов списка (используется для сравнения высказываний богов).
   
    ```Prolog
    compare_second([_, Y | _], [_, Y1 | _]) :- Y == Y1.
    ```
Результат работы программы:
```Prolog
?- task.
[dipl,lie,truth]
true .
```
Действительно, первый и второй боги не могут являться богами Правды, так как их высказывания противоречащие(если первый говорит правду, то втрой лжет; и наоброт, если второй говорит правду, то первый лжет). Значит бог Правды справа, тогда в центре бог Лжи и слева бог Дипломатии. Следовательно, противоречий нет, программа работает верно.

## Выводы

Выполнив данную работу, я приобрела навык решения логических задач на языке программирования Prolog. Prolog ищет решения, используя механизм backtracking, который позволяет ему переходить к альтернативным вариантам, если предыдущие привели к неуспеху. Это позволяет эффективно искать решения в пространстве всех возможных вариантов.

Данная реализации предоставленной задачи находит единственное и непротиворечивое решение. Программа безопасна, так как не взаимодействует с внешними данными и содержит корректные логические условия и проверки. Алгоритмическая сложность решения данной задачи может быть оценена, как O(n), где n - количество богов. Приведенная мною реализация имеет линейную сложность, следовательно, является достаточно эффективной.




